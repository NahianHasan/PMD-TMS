function [pp,Anor,tri,nhatp]=findSurf_real_head(p,th_hair,EEG_data_points,EEG_channels,tri_real,sphere_density,use_scalp_projection,use_nhat_projection,use_msh_smoothing,nhat_normalization,patch_angle)
    [pp,tri]=icosphere(sphere_density);
    pcen=(pp(tri(:,1),:)+pp(tri(:,2),:)+pp(tri(:,3),:))/3;    
    th=acos(pcen(:,3));
    ph=atan2(pcen(:,2),pcen(:,1));
    tri=tri(th<= (patch_angle/180*pi),:);%what part of the sphere to keep
    ntr=size(tri);
    [p1,~,tri]=unique(tri(:));
    pp=pp(p1,:);tri=reshape(tri,ntr);    
    
    %trisurf(tri,pp(:,1),pp(:,2),pp(:,3))
    th_pp=acos(pp(:,3));
    ph_pp=atan2(pp(:,2),pp(:,1));
    

    %%%%%%%%%%%%%%%%%% Construct EEG scatter interpolants%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %Notations
    %EEGPts1             = standard 329 EEG coordinates
    %EEGLab1             = standard 329 EEG coordinate labels
    %standard_EEGPts_new = sampled 76 standard EEG coordinate
    %standard_EEGLab_new = sampled 76 standard EEG coordinate labels
    %EEG_data_points     = individual EEG coordinates (from simnibs)
    %EEG_channels        = individual EEG channel names (from simnibs)
    %EEG_data_points_new = sampled individual EEG coordinates (from
    %                      simnibs). Only keep those coordinates whose corresponding standard
    %                      coordinate is available in the standard system
    load sphere_1005.mat
    standard_EEGPts_new = [];
    standard_EEGLab_new = [];
    EEG_data_points_new = [];
    for i=1:size(EEGPts1,1)
        for j=1:length(EEG_channels)
            if strcmp(EEGLab1(i),EEG_channels{j})
                standard_EEGPts_new = [standard_EEGPts_new;EEGPts1(i,:)];
                standard_EEGLab_new = [standard_EEGLab_new;EEGLab1(i)];
                EEG_data_points_new = [EEG_data_points_new;EEG_data_points(j,:)];
            end
        end
    end
    
    standard_EEGPts_new = standard_EEGPts_new./max(standard_EEGPts_new(:));
    th=acos(standard_EEGPts_new(:,3));
    ph=atan2(standard_EEGPts_new(:,2),standard_EEGPts_new(:,1));
    
    standard_trisphere_76 =delaunay(standard_EEGPts_new(:,1),standard_EEGPts_new(:,2),standard_EEGPts_new(:,3));
    [standard_trisphere_76]=surftri(standard_EEGPts_new,standard_trisphere_76);
    standard_trisphere_329=delaunay(EEGPts1(:,1),EEGPts1(:,2),EEGPts1(:,3));
    [standard_trisphere_329]=surftri(EEGPts1,standard_trisphere_329);
    
    [eegcoo_x,eegcoo_y,eegcoo_z,eegcoo_nx,eegcoo_ny,eegcoo_nz,eeg_nhatp] = form_scattered_interpolant(EEG_data_points_new,standard_trisphere_76,th,ph,1,use_msh_smoothing,nhat_normalization);
    
    %Find the projected hypothetical eeg coordinates from the hypothetical
    %eeg cap generated by the scattered interpolants
    pp = [eegcoo_x(th_pp(:),ph_pp(:)),eegcoo_y(th_pp(:),ph_pp(:)),eegcoo_z(th_pp(:),ph_pp(:))];
    nhatp = [eegcoo_nx(th_pp(:),ph_pp(:)),eegcoo_ny(th_pp(:),ph_pp(:)),eegcoo_nz(th_pp(:),ph_pp(:))];
    for i=1:numel(nhatp(:,1))
        nhatp(i,:)=nhatp(i,:)/norm(nhatp(i,:));
    end
    if use_scalp_projection
        scalp_points = (p(:,unique(tri_real)))';
        scalp_pp = zeros(size(pp));%Projected points onto the scalp
        if use_nhat_projection
            scalp_nhats = form_scattered_interpolant_nhat(p',tri_real);
            scalp_nhats = scalp_nhats(unique(tri_real),:);
            scalp_nhatp = zeros(size(nhatp));%new normal directions for the projected points
        end
        for idx=1:size(pp,1)
            [~,min_idx] = min(vecnorm(scalp_points - pp(idx,:),2,2));
            scalp_pp(idx,:) = scalp_points(min_idx,:);
            if use_nhat_projection
                scalp_nhatp(idx,:) = scalp_nhats(min_idx,:);
            end
        end
        if use_nhat_projection
            nhatp = scalp_nhatp;
        else
            scalp_nhatp = nhatp;
        end
        pp = scalp_pp;
        scalp_pp=scalp_pp+scalp_nhatp*th_hair;
    end
    %Move the eeg coordinates to the normal directions by the amount of
    %hair thickness
    for i=1:numel(nhatp(:,1))
        nhatp(i,:)=nhatp(i,:)/norm(nhatp(i,:));
    end
    pp=pp+nhatp*th_hair;

    %extract point normals and local coordinate systems
    Anor=zeros([4 4 numel(pp)/3]);
    thatp1=zeros(size(nhatp));
    thatp1(:,1)=1-nhatp(:,1).*nhatp(:,1);
    thatp1(:,2)=-nhatp(:,1).*nhatp(:,2);
    thatp1(:,3)=-nhatp(:,1).*nhatp(:,3);
    for i=1:numel(thatp1(:,1))
        thatp1(i,:)=thatp1(i,:)/norm(thatp1(i,:));
    end
    thatp2=cross(nhatp,thatp1);
    for i=1:numel(thatp2(:,1))
        thatp2(i,:)=thatp2(i,:)/norm(thatp2(i,:));
    end
    
    np = numel(thatp1(:,1));
    Anor(1:3,1,:)=reshape(thatp1',[3 1 np]);
    Anor(1:3,2,:)=reshape(thatp2',[3 1 np]);
    Anor(1:3,3,:)=reshape(nhatp',[3 1 np]);
    Anor(1:3,4,:)=reshape(pp',[3 1 np]);
    Anor(4,4,:)=1;
end

function [eegcoo_x,eegcoo_y,eegcoo_z,eegcoo_nx,eegcoo_ny,eegcoo_nz,nhatp] = form_scattered_interpolant(EEG_points,trisphere,th,ph,calc_nhat,use_msh_smoothing,nhat_normalization)
    th_i = [th;th;th];
    ph_i = [ph-2*pi;ph;ph+2*pi];
    
    %Form the scattered interpolant using the standard eeg angular
    %positions; We concatenate the cordinates for encountering the boundary
    %anomallies.
    EE_points_i = [EEG_points;EEG_points;EEG_points];
    eegcoo_x=scatteredInterpolant(th_i,ph_i,EE_points_i(:,1),'natural','linear');
    eegcoo_y=scatteredInterpolant(th_i,ph_i,EE_points_i(:,2),'natural','linear');
    eegcoo_z=scatteredInterpolant(th_i,ph_i,EE_points_i(:,3),'natural','linear');

    if calc_nhat
        nhatp = form_scattered_interpolant_nhat(EEG_points,trisphere,use_msh_smoothing,nhat_normalization);
        %Form the scattered interpolant using the standard eeg angular
        %positions; We concatenate the cordinates for encountering the boundary
        %anomallies.
        nhatp_i = [nhatp;nhatp;nhatp];
        eegcoo_nx=scatteredInterpolant(th_i,ph_i,nhatp_i(:,1),'natural','linear');
        eegcoo_ny=scatteredInterpolant(th_i,ph_i,nhatp_i(:,2),'natural','linear');
        eegcoo_nz=scatteredInterpolant(th_i,ph_i,nhatp_i(:,3),'natural','linear');
    else
        eegcoo_nx = [];
        eegcoo_ny = [];
        eegcoo_nz = [];
        nhatp = [];
    end
end

function nhatp = form_scattered_interpolant_nhat(EEG_points,trisphere,use_msh_smoothing,nhat_normalization)
    if use_msh_smoothing
        t=mean(sqrt(sum((EEG_points(trisphere(:,2))-EEG_points(trisphere(:,1),:)).^2,2)))^2/1000;
        [Wc,Ac]=graphlap(EEG_points',trisphere');
        EEG_points=(Ac-t*Wc)\EEG_points; %do a little smoothing for normal computations
    end
    %Find the normal directions for the individual eeg coordinate
    v1=EEG_points(trisphere(:,2),:)-EEG_points(trisphere(:,1),:);
    v2=EEG_points(trisphere(:,3),:)-EEG_points(trisphere(:,1),:);
    nhat=cross(v1,v2,2);
    clear v1 v2;
    area=sqrt(nhat(:,1).^2+nhat(:,2).^2+nhat(:,3).^2);
    nhat(:,1)=nhat(:,1)./area;
    nhat(:,2)=nhat(:,2)./area;
    nhat(:,3)=nhat(:,3)./area;
    nhatp=zeros(size(EEG_points));
    if strcmp(nhat_normalization,'mean_normal')
        %nhat contains multiple normal directions for a single coordinate
        %since each point is a part of multiple triangular facets. That's why
        %here we do the vector addition by combining each of the resultant
        %normal directions for a single point
        for i=1:numel(nhat(:,1))
            nhatp(trisphere(i,1),:)=nhatp(trisphere(i,1),:)+nhat(i,:);
            nhatp(trisphere(i,2),:)=nhatp(trisphere(i,2),:)+nhat(i,:);
            nhatp(trisphere(i,3),:)=nhatp(trisphere(i,3),:)+nhat(i,:);
        end
    elseif strcmp(nhat_normalization,'angle_mean_normal')
        for i=1:numel(nhat(:,1))
            v(:,1)=(EEG_points(trisphere(i,2),:)-EEG_points(trisphere(i,3),:));
            v(:,1)=v(:,1)/norm(v(:,1));
            v(:,2)=(EEG_points(trisphere(i,3),:)-EEG_points(trisphere(i,1),:));
            v(:,2)=v(:,2)/norm(v(:,2));
            v(:,3)=(EEG_points(trisphere(i,1),:)-EEG_points(trisphere(i,2),:));
            v(:,3)=v(:,3)/norm(v(:,3));
            %a.b = |a||b|cos(theta); |a|=|b|=1
            nhatp(trisphere(i,1),:)=nhatp(trisphere(i,1),:)+acos(-sum(v(:,mod(1,3)+1).*v(:,mod(2,3)+1)))*nhat(i,:);
            nhatp(trisphere(i,2),:)=nhatp(trisphere(i,2),:)+acos(-sum(v(:,mod(2,3)+1).*v(:,mod(3,3)+1)))*nhat(i,:);
            nhatp(trisphere(i,3),:)=nhatp(trisphere(i,3),:)+acos(-sum(v(:,mod(3,3)+1).*v(:,mod(4,3)+1)))*nhat(i,:);
        end
    end

    %Normalize the vectors to find the unit vectors.
    for i=1:numel(nhatp(:,1))
        nhatp(i,:)=nhatp(i,:)/norm(nhatp(i,:));
    end
    nhatp(isnan(nhatp)) = 0;
end
